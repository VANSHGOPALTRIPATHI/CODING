// top down approach->


class Solution {
public:
int solve ( vector<int>&cost,int n,vector<int>&dp){
    if (n==0)
        return cost[0];
    if (n==1)
        return cost[1];
    // step 3
    if (dp[n]!=-1){
        return dp[n];
    }
    //step 2
    dp[n] = cost[n]+min(solve(cost,n-1,dp),solve(cost,n-2,dp));
    return dp[n];  
}

    int minCostClimbingStairs(vector<int>& cost) {
        int n= cost.size();
        //step 1
        vector<int> dp(n+1,-1);
        int ans = min(solve(cost,n-1,dp),solve(cost,n-2,dp));
        return ans;
        
    }
};
//**************************************************************************************************************************************

// bottom up approach->


class Solution {
public:

    int minCostClimbingStairs(vector<int>& cost) {
        int n= cost.size();
        vector<int> dp(n+1);
        dp[0]=cost[0];
        dp[1]=cost[1];



        for (int i=2 ;i<n ;i++){
            dp[i]=cost[i]+min(dp[i-1],dp[i-2]);
        }
        return min(dp[n-1],dp[n-2]);
        
        
    }
};
//****************************************************************************************************************************************

// space optimization approach->


class Solution {
public:

    int minCostClimbingStairs(vector<int>& cost) {
        int n= cost.size();
        vector<int> dp(n+1);
        int first=cost[0];
        int second=cost[1];



        for (int i=2 ;i<n ;i++){
            int curr= cost[i]+min(first,second);
            first=second;
            second=curr;
        }
        return min(first,second);
        
        
    }
};